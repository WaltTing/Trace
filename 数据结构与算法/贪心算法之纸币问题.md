# 贪心算法之纸币问题
我们先以这个算法问题开头。

> 给定一个数目的人民币n，输出最小的货币方案。

样例输入：

> 513

输出：
> 8

分析：

已知人民币的面值是：1 2 5 10 20 50 100。要我们输出人民币的总张数最小的方案。我们当然会选择用尽可能大的面值去凑，具体来说，就是

1. 先用100来试，如果大于100，就可以换n/100张100，
2. 用100去凑之后会得到零头，再用50去凑这些零头，如果一张50不够，或者零头不够50，
3. 用20去凑，
4. 。。。。。。

比如下面的程序：  

		import java.util.Scanner;
		
		public class dafuweng {
		    public static void main(String[] args){
		        Scanner sc = new Scanner(System.in);
		        int n = sc.nextInt();
		        int count = 0;
		
		        int money[] = new int[]{100,50,20,10,5,2,1};
		
		        for(int i=0; i<7; i++){
		            if(n/money[i] > 0) {
		                count += n / money[i];
		                System.out.println(n/money[i]+"张"+money[i]+"面值");
		                n = n % money[i];
		            }
		        }
		
		        System.out.println("总共"+count+"张");
		    }
		}


人民币问题是**贪心算法**的经典案例之一，贪心算法的定义是，*求解问题时，总是做出当前看来最好的选择*。

所以解题的步骤一般是：

1. 建立数学模型
2. 将求解问题划分成若干小问题
3. 对每一个小问题进行求解，得到局部最优解
4. 若干局部最优解合成了问题的最优解

思考上面的算法，很简单，它的思路就是，考虑当前最优，什么是最优，不管后面会怎样，我就是要用最大面值来凑数，零头给后面去凑就行了。

所以贪心算法也有限制，就是局部的选择必须不能影响之后的选择。比如同样很经典的**背包问题**，就必须用到**动态规划**来求解。